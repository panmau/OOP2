%import template
\input{./template.tex}

% DocInfo
\newcommand{\SUBJECT}{}
\newcommand{\TITLE}{Cheat Sheet Objektorientierte Programmierung 2}

\begin{document}

%do multicols
\begin{multicols*}{5}
    \setlength{\columnseprule}{0.4pt}
		\footnotesize

\section{Allgemeines}
	\subsection{?}
	% TODO?!

\section{Big O}

	\subsection{Beweis}
	\begin{itemize}
		\item Annahme: 2n + 10 ist O(n)
		\item $2n + 10 \leq cn$
		\item $10 \leq cn - 2n$
		\item $10 \leq (c - 2)n$
		\item $\frac{10}{c-2} \leq n$
		\item $=> c=3$ und $n0=10$
		\item Es gibt viele Belegungen für $c$ und $n0$
	\end{itemize}

	\subsection{Beispiel}
	\begin{lstlisting}
public static void function(int[] array) {
	// O(n)
	for (int i = 1; i < array.length + 1; i++) {
		// O(log n)
		for (int i1 = 1; i1 < array.length; i1*=2) {
			System.out.println(array[i - 1]);
		}
	}
}
// -> O(n * log n)
	\end{lstlisting}

\section{Verschiedene Algorithmen}
	\subsection{Eigenschaften}

	\renewcommand{\arraystretch}{1.1}
	\begin{tabular}{c | c | c}
		Algo & Worst & Avg \\
		\hline
		Binary Search & O(log n) & \\
		Insertion & O($n^2$) &  \\
		Selection & O($n^2$) &  \\
		Bubble & O($n^2$) &  \\
		Merge & O(n log n) &  \\
		Quick & O($n^2$) & O(n log n)
	\end{tabular}
	
	\subsection{Implementationen}
		\subsubsection{Binary Search}
			\begin{lstlisting}
public int searchBinary(int[] intArr, int start, int end, int searchElement) {
	if (start > end || intArr.length == 0) {
		return null;
	}

	int pivot = (start + end) / 2);
	if (pivot >= intArr.length){
		return null;
	}
	if (searchElement > intArr[pivot]) {
		searchBinary(intArr, pivot + 1, end, searchElement);
	} else if (searchElement < intArr[pivot] && start != pivot) {
		searchBinary(intArr, start, pivot - 1, searchElement);
	} else if(searchElement == intArr[pivot]) {
		return intArr[pivot]
	} else{
		return null;
	} }
			\end{lstlisting}
		
		\subsubsection{Insertion Sort}
		Für jedes neue Element wird geprüft, wo in der sortierten Liste es hingehört
			\begin{lstlisting}
void insertionSort(char[] data) {
	for (int k = 1; k < data.length; k++) {
		char cur = data[k];
		int j = k;
		while (j > 0 && data[j - 1] > cur) {
			data[j] = data[j - 1];
			j--;
		}
		data[j] = cur;
	} }
			\end{lstlisting}
		
		\subsubsection{Selection Sort}
		Kleinstes/grösstes Element suchen und an richtige Stelle verschieben
		
			\begin{lstlisting}
void selectionSort(int[] array) {
	int marker = array.length - 1;
	while (marker >= 0) {
		int max = 0;
		for (int i = 1; i <= marker; i++) {
			if (array[i] > array[max]) {
				max = i;
			}
		}
		swap(array, marker, max);
		marker--;
	} }
			\end{lstlisting}
		
		\subsubsection{Bubble Sort}
		Array von links nach rechts durchgehen, wenn Element grösser als rechter Nachbar, austausczhen
			\begin{lstlisting}
void bubbleSort(int[] array) {
	for (var n = array.length; n > 1; n--) {
		for (var i = 0; i < n - 1; i++) {
			if (array[i] > array[i + 1]) {
				swap(array, i, i + 1);
			}
		}
	} }
			\end{lstlisting}
		
		\subsubsection{Merge Sort}
		S auf Folgen S1 und S2 verteilen, rekursiv sortieren, S1 und S2 in sortierter Folge zusammenfassen
			\begin{lstlisting}
int[] mergeSort(int[] elem, int left, int right) {
	if (left == right)
	  	return new int[]{elem[left]};
	int middle = left + (right - left) / 2;
	int[] leftArray = mergeSort(elem, left, middle);
	int[] rightArray = mergeSort(elem, middle + 1, right);
	return merge(leftArray, rightArray);
}

int[] merge(int[] leftArray, int[] rightArray) {
	int leftLen = leftArray.length;
	int rightLen = rightArray.length;
	int[] target = new int[leftLen + rightLen];
	int targetPos = 0;
	int leftPos = 0;
	int rightPos = 0;// As long as both arrays contain elements...
	while (leftPos < leftLen && rightPos < rightLen) {
		// Which one is smaller?
		int leftValue = leftArray[leftPos];
		int rightValue = rightArray[rightPos];
		if (leftValue <= rightValue) {
			target[targetPos++] = leftValue;
			leftPos++;
		} else {
			target[targetPos++] = rightValue;
			rightPos++;
		}
	}
    // Copy the rest
	while (leftPos < leftLen) {
		target[targetPos++] = leftArray[leftPos++];
	}
	while (rightPos < rightLen) {
		target[targetPos++] = rightArray[rightPos++];
	}
	return target;
}
			\end{lstlisting}
		
		\subsubsection{Quick Sort}
		Pivot wählen, in zwei Arrays teilen, eines mit x < Pivot, eines mit x > Pivot, rekursiv auf Unterarrays Quicksort aufrufen
			\begin{lstlisting}
void quickSort(int[] arr, int low, int high) {
	if (low < high) {
		int pi = partition(arr, low, high);
		quickSort(arr, low, pi - 1);
		quickSort(arr, pi + 1, high);
	}
}
	
int partition(int[] arr, int low, int high) {
	int pivot = arr[high];
	int i = low - 1;
	for (int j = low; j <= high - 1; j++) {
		if (arr[j] < pivot) {
			i++;
			swap(arr, i, j);
		}
	}
	swap(arr, i + 1, high);
	return i + 1;
}
			\end{lstlisting}
		
\section{Bäume}
	\begin{itemize}
		\item \textbf{innere Knoten}: Knoten mit min. einem Kind
		\item \textbf{Blatt}: Knoten ohne Kinder
		\item \textbf{Wurzel}: Knoten ohne Elternknoten
		
	\end{itemize}

	\subsection{Höhe}
	Maximale Tiefe der Knoten im Baum
		\begin{lstlisting}
public int height(Position<E> p) {
	int h = 0;
	for (Position<E> c : children(p)) {
		h = Math.max(h, 1 + height(c));
	}
	return h; }
		\end{lstlisting}
	
	\subsection{Tiefe}
	Anzahl Vorgänger
		\begin{lstlisting}
public int depth(Position<E> p) {
	if (isRoot(p)) {
		return 0;
	} else {
		return 1 + depth(parent(p));
	} }
		\end{lstlisting}
	\subsection{Traversierung}
		\subsubsection{Preorder W-L-R}
			\begin{lstlisting}
visit(v)
for each child w of v
  preOrder(w)
			\end{lstlisting}
		
		\subsubsection{Postorder L-R-W}
			\begin{lstlisting}
for each child w of v
  postOrder(w)
visit(v)
			\end{lstlisting}
		
		\subsubsection{Breadth-First}
		Alle Knoten der Tiefe t besuchen, bevor Knoten der Tiefe t+1 besucht werden
			\begin{lstlisting}
// Initialize queue Q containing root
while Q not empty
  v = Q.dequeue()
  visit(v)
  for each child w in children(v)
    Q.enqueue(w)
			\end{lstlisting}
		
		\subsubsection{Inorder L-W-R}
			\begin{lstlisting}
if hasLeft(v)
  inOrder(left(v))
visit(v)
if hasRight(v)
  inOrder(right(v))
			\end{lstlisting}

	\subsection{Preorder Iterator}
		\begin{lstlisting}
public T next() {
if (stack.empty()) {
	stack.push(root);
}
Node<T> node = stack.pop();
if (node.getRight() != null) {
	stack.push(node.getRight());
}
if (node.getLeft() != null) {
	stack.push(node.getLeft());
}
if (stack.empty()) {
	root = null;
}
return node.getValue(); }
		\end{lstlisting}


\section{Algorithmenparadigmen}
	\subsection{Backtracking}
		\subsubsection{Cookbook}
			\begin{itemize}
				\item Position markieren
				\item Rekursionsabbruch: return true
				\item Alle Optionen probieren
					\item => neues Feld festlegen
					\item => Überprüfen ob gültig \& nicht besucht
					\subitem => prüfen ob rekursiver Aufruf true? 
					\subitem Falls ja: return true
				\item Backtracking: Markierung vom Feld entfernen und return false
			\end{itemize}			
		
		\subsubsection{Beispiel Knights Tour}
			\begin{lstlisting}
private boolean isValid(int x, int y) {
	return x >= 0 && y >= 0 && x < N && y < N;
}

public boolean knightTour(int[][] visited, int x, int y, int pos) {
	// jetzige Position markieren
	visited[x][y] = pos;
	// alle Felder besucht => abbrechen (return true)
	if (pos >= N * N) {
		print(visited);
		return true;
	}
// Alle erlaubten Bewegungen überprüfen
	for (int k = 0; k < 8; k++) {
		int newX = x + row[k];
		int newY = y + col[k];
		// neue Position auf Feld und noch nicht besucht
		if (isValid(newX, newY) && visited[newX][newY] == 0) {
			// Wenn die Rekursion ein Weg gefunden hat
			if (knightTour(visited, newX, newY, pos + 1)) {
				return true;
			}
		}
	}
	
	// Markierung entfernen und backtracken
	visited[x][y] = 0;
	return false;
}
			\end{lstlisting}

	\subsection{Greedy}
	Lösung wählen, die im Teilschritt möglichst nahe ans Ziel kommen.
	Beispiel Rückgeld: Grösste Münze von Betrag abziehen

	\subsection{Teile \& Herrsche}
		\begin{itemize}
			\item Problem aufteilen
			\item Kleinere Probleme lösen
			\item Rekursive Rückführung des Problems auf identisches Problem mit kleinerer Eingabemenge
		\end{itemize}
	
	\subsection{Dynamische Programmierung}
		\begin{itemize}
			\item Greedy
			\item Mehrfach auftretende Probleme nur einmal berechnen
			\item Lösung auf Grundlage bereits berechneter Ergebnisse finden
		\end{itemize}

\section{Abstrakter Datentyp}
Beschreibt Datenstruktur unabhängig von konkreter Implementierung.
Beschreibt Attribute, Operationen auf den Attributen, Ausnahmen und Fehler
Beschreibt das Was aber nicht das Wie.

\subsection{Datenstrukturen}
	\begin{itemize}
		\item Speichern und organisieren Daten.
		\item Implementieren einen ADT (Schnittstelle)
	\end{itemize}

	\subsubsection{Laufzeiten}

		\begin{tabular}{c | c | c}
			& Array & Linked List \\
			\hline
			Lesen & O(1) & O(n) \\
			Einfügen & O(n) & O(1)  \\
			Suchen & O(n) & O(n) \\
		\end{tabular}
	
		\begin{tabular}{c | c | c}
			\textbf{HashMap} & Avg & Worst \\
			\hline
			Lesen & O(1) & O(n) \\
			Einfügen & O(1) & O(n)  \\
			Suchen & O(1) & O(n) \\
		\end{tabular}

\section{Design Patterns}
	Arten von Design Patterns
	\begin{itemize}
		\item \textbf{Erzeugunsmuster}: Abstrahieren Instanziierung 
		\item => (Factory, Singleton, ...)
		\item \textbf{Strukturmuster}: Zusammensetzung von Klassen \& Objekten zu grösseren Strukturen
		\item => Adapter, Fassade, ...
		\item \textbf{Verhaltensmuster}: Algorithmen und Verteilung von Verantwortung zwischen Objekten
		\item => Iterator, Visitor, ...
	\end{itemize}
	\subsection{Iterator}
	Sequentiell auf Elemente in Aggregatobjekt zugreifen, ohne zugrundeliegende Struktur offen zu legen
	
	\subsection{Adapter}
	Klasse modifizieren, dass Schnittstelle zu Schnittstelle der anderen Klasse passt.
	
	Ermöglicht Code wieder zu verwenden ohne anzupassen.
	
	Objekt Adapter:
	\begin{lstlisting}
class Adapter extends ClassWeWantToMatch {
	private ExistingClass obj;
	public void method() {
		obj.otherMethod();
	}
}
	\end{lstlisting}

	\subsection{Template}
	\begin{itemize}
		\item Gemeinsame unveränderlichen Teile in abstrakter Klasse implementiert
		\item Variable Schritte werden in Methode ausgelagert
		\item Variable Schritte repräsentieren Hooks/Platzhalter, die in konkreten Subklassen implementiert werden.
	\end{itemize}

	\subsection{Visitor}
	Beschreibt Operationen auf Elementen einer anderen Datenstruktur.
	
	Trennung von Algorithmen und Datenstrukturen auf denen sie operieren. 
	
	Visitor enthält Algorithmen für unterschiedliche Datenstrukturen.
	\begin{itemize}
		\item \textbf{Einfache} Erweiterbarkeit, wenn neue Algorithmen hinzugefügt werden
		\item \textbf{Grösserer} Änderungsbedarf, wenn neue Klassen ergänzt werden
	\end{itemize}

\section{Hash}

	\subsection{Eigenschaften guter Hashfunktionen}
	\begin{itemize}
		\item konsistente Ergebnisse
		\item konstanter Zeitbedarf
		\item Gleichmässige Verteilung der Schlüssel
	\end{itemize}

	\subsection{Mögliche Hash Algorithmen}
		\subsubsection{Integer Cast}
		Schlüssel als Integer interpretieren
		
		• Gut, wenn Anzahl Bits Interpretation als Integer erlaubt
	
		\subsubsection{Komponentensumme}
		• Bits des Schlüssels in Komponenten fixer Länge (16/32 Bits) unterteilen
		
		• Komponenten summieren, Overflow ignorieren
		
		• Gut für Schlüssel fixer Länge, grösser/gleich Anzahl Bits von Integer
		
		\begin{lstlisting}
int hash = 0;
for (int i = 0; i < s.length(); i++) {
	hash = (R * hash + s.charAt(i)) % m;
	// R ist Konstante. Eine kleine Primzahl
}
		\end{lstlisting}	
	
	\subsection{Polynom-Akkumulation}
	• Hashing von Werten der Form ($x_0, x_1 , ..., x_n-1$") schwierig durch Addition
	
	% TODO: How do I get n-1 at the bottom instead of just n?
	Polynom:
	$p(z) = a_0 + a_1z + a_2z^2 + ... + a_n-1$
		
	Gut für Strings. Mit z=33 maximal 6 Kollisionen bei 50'000 englischen Wörtern.
		
	\subsection{Kollisionsbehandlung}
		\subsubsection{Geschlossene Adressierung}
		Behälter von Map sind (verkettete) Listen
		
		Platz nicht begrenzt, Prinzipiell keine Überläufer
		
		\subsubsection{Offene Adressierung}
		Für Überläufer in anderen Behältern Platz suchen
		
		Sondierungsfolge bestimmt Weg zum Speichern und Wiederauffinden der Überläufer
		
		Lineare Sondierung: Überläufer in nächste verfügbar Zelle einfügen
		
		\textbf{Löschen}: Erfordert besondere Behandlung.
		
		Wird Datensatz gelöscht, kann dies Sondierungsfolge für anderen Datensatz unterbrechen.
		
		Datensätze nicht physisch löschen, sondern nur als gelöscht markieren. (Behälter ist: frei, belegt oder gelöscht)
		
	\subsection{Erweiterbares Hashing}
		Beim erweiterbaren Hashing wird binäres Ergebnis der Hashfunktion verwendet, die auf einen grösaseren Bereich abbildet.
		
		Beim Überlauf eines Behälters wird ein weiteres Bit des Hashwertes hinzugezogen.
		
		Somit ist keine Reorganisation der gesamten Tabelle notwendig.

\section{Generics}
Type Erasure!

	\begin{tabular}{c | c}
		\textbf{Conventions} &  \\
		\hline
		T & Type \\
		K & Key \\
		V & Value \\
		N & Number \\
		E & Element \\
		S, U, V, ... & 2nd, 3rd, 4th \\
	\end{tabular}

	\begin{lstlisting}
Stack<String> genericStack = new Stack<String>();
Stack rawStack = genericStack;
// This works but loses type info, gives a warning
// Type only gets checked at runtime
	\end{lstlisting}

\vspace{5pt}

	\begin{lstlisting}
public class Stack<T> { ... }
interface Iterator<E> { ... }

// Class doesn't necessarily need to be generic
public <E> Stack<E> push(E value) { ... }
	\end{lstlisting}

	\subsection{Constraints}
		\begin{lstlisting}
... <T extends Graphic>
... <T extends Type1 & Type2 & ... >
// As Java doesn't allow Diamond inheritance only one can be a class
... <T super Graphic>

		\end{lstlisting}
	
	\subsection{Generische Type Invariance}
		\begin{lstlisting}
// This doesn't work. 
// Types need to be exactly the same
List<Number> ns = new ArrayList<Integer>();

Collection<? extends T> x = ....
Collection<? super T> y = ...
		\end{lstlisting}

\columnbreak
\section{Beispiele}

	\subsubsection{Switch - Case}
	\begin{lstlisting}
int x = 5; 
switch(x) {
	case 2: 
		System.out.println("2"); 
		break;
	case 5: 
		System.out.println("5"); 
		break;
	default: 
		System.out.println("No match!"); 
}
	\end{lstlisting}

	\subsubsection{for loop}
	\begin{lstlisting}
	for(int i = 0; i < list.size(); i++) {}
	
	for(var el : list) {}
	
	for(var el : set) {}
	
	for(var el : map.entrySet()) {
		var k = el.getKey();
		var v = el.getValue();
	}
	\end{lstlisting}

	\subsubsection{Main Methode}
	\begin{lstlisting}
	public static void main(String[] args) {...}	
	\end{lstlisting}

	\subsubsection{Interface}
	\begin{lstlisting}
	public interface GraphicItem {
		Vector getLocation();
		void move(Vector delta);
		
		// A default implementation:
		default void moveToCenter() {
			var pos = getLocation();
			move(new Vector(-pos.getX(), -pos.getY()));
		}
	}
	\end{lstlisting}

	\columnbreak

	\subsubsection{Alle Wörter aus Buchstaben generieren}
		\begin{lstlisting}
Set<String> generateWords(Set<Character> input) { 
	Set<String> result = new HashSet<>();
	if (input.size() == 0) { 
		result.add(""); 
	}
	for (Character letter : input) {
		Set<Character> remainder = new HashSet<>(input); 
		remainder.remove(letter);
		for (String word : generateWords(remainder)) {
			result.add(word + letter);
		}
	}
	return result;
}
		\end{lstlisting}
	
	\subsubsection{Custom 'Linked List'}
	\begin{lstlisting}
public class Car {
	private Car next;
	// ...
}
public class Locomotive {
	private Car first;
	// ...
}
public class Train {
	private Locomotive locomotive;
	public Train() {
		locomotive = new Locomotive();
	}
	
	public void add(String name) {
		Car first = locomotive.getFirst();
		Car newCar = new Car(name);
		newCar.setNext(first);
		locomotive.setFirst(newCar);
	}
	
	public boolean insert(int position, String name) {
		if (position == 0) {
			add(name);
			return true;
		}
		Car leadingCar = getCar(position - 1);
		if (leadingCar == null) {
			return false;
		}
		Car followingCar = leadingCar.getNext();
		Car newCar = new Car(name);
		leadingCar.setNext(newCar);
		newCar.setNext(followingCar);
		return true;
	}
	
	public void reverse() {
		Car previousCar = null;
		Car currentCar = locomotive.getFirst();
		while (currentCar != null) {
			Car nextCar = currentCar.getNext();
			currentCar.setNext(previousCar);
			previousCar = currentCar;
			currentCar = nextCar;
		}
		locomotive.setFirst(previousCar);
	}
	
	public Car removeFirst() {
		Car firstCar = locomotive.getFirst();
		if (firstCar != null) {
			locomotive.setFirst(firstCar.getNext());
		}
		return firstCar;
	}
}
	\end{lstlisting}
	

\end{multicols*}

% \input{./appendix.tex}

\end{document}